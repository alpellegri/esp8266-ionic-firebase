1. Data Definitions
   ================

  These entities are defined into a database.

  definition
  key: {
    owner: <owner>, // it is a string
    name: <name>,   // it is a string
    code: <type>,   // it is a string (enum?)
    value: <value>, // it is dynamic: a string or a number
    cb: <callback>, // it is a string representign the key of the database
  }
  type: {phyin, phyout, login, logout, bool, int, float}

* physical i/o
  type: {phyin, phyout}
  i/o are addressed by id (port, value: v)

  . input is scanned periodically (or event driven)
    on change can generate a call back
  . output is program driven

  input
  identifier = pin<<24
  key: {
    owner: <owner>,
    name: <name>,
    code: phyin,
    value: <identifier>, // it is a number
    cb: <callback>,
  }

  output
  identifier = pin<<24|value
  key: {
    owner: <owner>,
    name: <name>,
    code: phyout,
    value: <identifier>, // it is a number
    cb: <callback>,
  }

* timer is a logical value.
  it variable descibing the time in a day or a week.
  Time is represent a tick (a minute) inside a day (24*60=1440 ticks) or a week
  (7*24*60=34560 ticks) time is a modulo number.
  in case of modulo-day 1439+1 overflow to 0, in case of modulo-week 34559+1 overflow to 0.
  The idea is to use this as a base for event generation. When its value change a callback may be
  called.
  
  key-timer: {
    owner: <owner>,
    name: <namer>,
    code: timer,
    value: <configuration>, // it is a int
    cb: <callback>,
  }
  hour: (5bits)
  minutes: (6bits)
  map: weekday bitmap (7bits)
  configuration: map<<11|hour<<6|minutes (18bits)
  
  At start VM read all timers from DB and store them to RAM. VM generates callbacks when timer value
  is reached

* radioin is a logical value.
  key-radio: {
    owner: <owner>,
    name: <radio>,
    code: radioin,
    value: <configuration>, // it is a int
    cb: <callback>,
  }
  configuration: mask

  At start VM read all radiomach from DB and store them to RAM.
  if (radio & mask) == mask an event is 
  VM call callback cb when (radio & mask) == mask
  and ACC = radio & ~mask

* radin is a logical value.
  key-radio: {
    owner: <owner>,
    name: <radio>,
    code: radiorx,
    value: 0, // not used
    cb: <callback>,
  }

  VM call callback cb when a radio is received and no match happened
  and ACC = radio

* radioout is a logical value.
  key-radio: {
    owner: <owner>,
    name: <radio>,
    code: radioout,
    value: <configuration>, // it is a int
    cb: <callback>,
  }
  configuration: mask
  
  At start VM read all radioin from DB and store them to RAM.

* notify is a logical values
  key-notify: {
    owner: <owner>,
    name: <name>,
    code: logout,
    value: kmessage, // it is a string
    cb: <callback>,
  }

* variables are input/output and may have a callback
  These entities are defined into a database.
  Variable are read periodically or at event and copyed into local
  type: {bool, int, float}

  generic definition
  key: {
    owner: <node>,  // it is a string
    name: <name>,   // it is a string
    code: <type>,   // it is a string (enum)
    value: <value>, // it is a dynamic
    subscriber: {   // this is an array
      <node>: <callback>,
      ...,
      <node>: <callback>,
    },
  }

2. Function Definitions
   ====================

These entities are defined into a database.

Functions run into a simple virtual machine.
The VM fetch instruction and data and execute them.
VM is provided by a accumulator register ACC.
At startup all DB entities are locally copied into the runtime environment.

functions: execute a statement of a program, can call other statement

  key: {
    name: <name>,   // it is a string
    code: <instr>,  // it is a string (enum?)
    value: <arg>,   // it is dynamic: a string or a number
    cb: <callback>, // it is a string representign the key of the database
  }

  instr: {
    ldi, // load immediate arg value into ACC (this involves a fetch from DB)
    ld,  // load arg value into ACC (this involves a fetch from DB)
    st,  // store arg value into ACC (this involves a write back to DB)
    rd,  // read arg value locally into ACC
    wr,  // write arg value locally into ACC
    lt,  // if ACC is less than arg, then ACC=1, else ACC=0
    gt,  // if ACC is grater than arg, then ACC=1, else ACC=0
    eqi, // if ACC is equal to immediate arg value, then ACC=1, else ACC=0
    eq,  // if ACC is equal to arg, then ACC=1, else ACC=0
    bz,  // branch if ACC is zero
    bnz, // branch if ACC is not zero
  }
  
A1. example simple sensor trigger
   =============================

sensor: physical input mapped on a pin
thr1: variable

pseudo-code:
  if (sensor>thr) {
    status = true;
  } else {
    status = false;
  }
  
or:
  status = (sensor>thr);

key-sensor: {
  name: 'sensor',
  code: phyin,
  value: pin<<24,
  cb: key-f01,
}
key-thr1: {
  name: 'thr1',
  code: var,
  value: 90,
  cb: end,
}
key-status: {
  name: 'status',
  code: bool,
  value: 0,
  cb: end,
}

f01: rd v, f02
f02: lt thr, f03
f03: wr status, end

A2. example led on/off depending by a variable
   ==========================================

led: physical output mapped on a pin
status: variable

pseudo-code:
  if (status != 0) {
    led = true;
  } else {
    led = false;
  }

or:
  led = (status != 0);

instruction-code:
f01: ld status, f02
f02: eqi 0, f03
f03: st led, end

key-led: {
  name: 'led',
  code: phyout,
  value: pin<<24,
  cb: end,
}
key-status: {
  name: 'status',
  code: bool,
  value: 0,
  cb: key-f01,
}
key-f01: {
  name: 'f01',
  code: ld,
  value: key-status,
  cb: key-f02,
}
key-f02: {
  name: 'f02',
  code: eqi,
  value: 0,
  cb: key-f03,
}
key-f03: {
  name: 'f03',
  code: st,
  value: key-led,
  cb: end,
}

A3. example sensor trigger with hysteresis switching a relay
   ========================================================

pseudo-code:

init:
  status = false;
  thr1 = 90
  thr2 = 110

run:
  if (status == true) {
    if (sensor<thr1) {
      status = false;
    }
  } else {
    if (sensor>thr2) {
      status = true;
    }
  }

sensor: physical input mapped on a pin
key-sensor: {
  name: 'sensor',
  code: phyin,
  value: pin<<24,
  cb: key-f01,
}

status: variable
key-status: {
  name: 'status',
  code: bool,
  value: 0, // only the init value
  cb: end,
}
key-thr1: {
  name: 'thr1',
  code: int,
  value: 90,
  cb: end,
}
key-thr2: {
  name: 'thr2',
  code: int,
  value: 110,
  cb: end,
}

instruction-code:
f01: rd status, f02
f02: bz f6, f03
f03: ld sensor, f04
f04: lt thr1, f05
f05: bz end, f09
f06: ld sensor, f07
f07: lt thr1, f08
f08: bnz end, f09
f09: wr status, end

functions
key-f01: {
  name: 'f01',
  code: rd,
  value: key-status,
  cb: key-f02,
}
key-f02: {
  name: 'f02',
  code: bz,
  value: key-f06,
  cb: key-f03,
}
key-f03: {
  name: 'f03',
  code: ld,
  value: key-sensor,
  cb: key-f04,
}
key-f04: {
  name: 'f04',
  code: lt,
  value: key-thr1,
  cb: key-f05,
}
key-f05: {
  name: 'f05',
  code: bz,
  value: end,
  cb: key-f09,
}
key-f06: {
  name: 'f06',
  code: ld,
  value: key-sensor,
  cb: key-f07,
}
key-f07: {
  name: 'f07',
  code: lt,
  value: key-thr2,
  cb: key-f08,
}
key-f08: {
  name: 'f08',
  code: bnz,
  value: end,
  cb: key-f09,
}
key-f09: {
  name: 'f09',
  code: wr,
  value: key-status,
  cb: key-f10,
}
key-f10: {
  name: 'f10',
  code: st,
  value: key-led,
  cb: end,
}

diagram
:)f01~rd)--:)f02~bz)--:)f03~rd)--:)f04~lt)--:)f05~bz)--:)f09~wr
status      f06   |    v          thr1       end      | status
                  |                                   |
                  +--:)f06~rd)--:)f07~gt)--:)f08~bnz)-+
                     v          thr2       end

diagram
v->(f01: rd status)->(f02: bz f06)->(f03: rd v)->(f04: lt thr1)->(f05: bz end)->(f09: wr status)->(f10: st led)->end
                              |                                               |
                              +---->(f06: rd v)->(f07: gt thr2)->(f08: bnz)---+

A4. example radio code and alarm
   =============================

sensor: radioin input
id: radiorx input
alarm-status: variable
last-radio: variable

pseudo-code:
  if (sensor == true) {
    if (alarm-status == true) {
      notify = true;
    }
  }
  if (id == true) {
    last-radio = id;
  }

key-sensor: {
  name: 'sensor',
  code: radioin,
  value: 0xffaaff, // configuration
  cb: key-f01,
}
key-id: {
  name: 'id',
  code: radiorx,
  value: 0,
  cb: key-f04,
}
key-unknown-radio: {
  name: 'unknown-radio',
  code: int,
  value: 0,
  cb: end,
}
key-notify: {
  name: 'notify',
  code: logout,
  value: kmessage,
  cb: end,
}
key-alarm-status: {
  name: 'alarm-status',
  code: bool,
  value: 0, // only the init value
  cb: end,
}
key-f01: {
  name: 'f01',
  code: rd,
  value: key-alarm-status,
  cb: key-f02,
}
key-f02: {
  name: 'f02',
  code: bz,
  value: end,
  cb: key-f03,
}
key-f03: {
  name: 'f03',
  code: st,
  value: key-notify,
  cb: end,
}
key-f04: {
  name: 'f06',
  code: st,
  value: key-unknown-radio,
  cb: end,
}

A5. timer control led
   ==================
led: physical output mapped on a pin
Time is a physical values

pseudo-code:
  if (timer1 == true) {
    led = true;
  }
  if (timer2 == true) {
    led = false;
  }

key-timer1: {
  name: <name>,
  code: int,
  value: 0*60+0,
  cb: key-f01,
}
key-timer2: {
  name: <name>,
  code: int,
  value: 0*60+1,
  cb: key-f02,
}
key-led: {
  name: 'led',
  code: phyout,
  value: pin<<24,
  cb: end,
}
key-f01: {
  name: 'f01',
  code: ldi,
  value: 1,
  cb: key-f03,
}
key-f02: {
  name: 'f01',
  code: ldi,
  value: 0,
  cb: key-f03,
}
key-f03: {
  name: 'f03',
  code: st,
  value: key-led,
  cb: end,
}
